# 다트 게임 (2018/맞춘사람 수)



9.16 - 시작

9.28 - Re 모듈 좀 손봤음

9.58 - 정답률 93.8



## 문제 분석

다트 점수 총합 계산하는 문제

점수 + 보너스 + 옵션이 주어짐 



- 점수 + 보너스 + 옵션 을 split 하기
  - split 하기 애매 , 정규옵션을 잘활용하면 쉽게 할거같은데
- 보너스 + 옵션 적용 로직





- RE 모듈 잘쓰면 편할거같다
- 0 일때도 `*` 옵션 유효

- 유사한기능을 옵션에 따라 적용해야할때 if 문으로 나누는것보다 dict 을 만들어서 적용하는게 훨씬 깔끔하다



##  코드

```python
import re

def solution(dartResult):
    answer = 0
    lst = []
    for i,c in enumerate(dartResult):
        if c.isdigit():
            temp = [c , dartResult[i+1] ]
            try : 
                if not dartResult[i + 2].isalnum():
                    temp.append(dartResult[i+2])                
            except : pass
            lst.append(temp)
    print(lst)
                  
```



```python

import re

def solution(dartResult):
    answer = 0
    lst = []
    
        
    for i,c in enumerate(dartResult):
        
        if c == "0": continue
        if c.isdigit():
            if dartResult[i + 1].isdigit():
                temp = [int(dartResult[i:i+2]) , dartResult[i+2] ]
                try : 
                    if not dartResult[i + 3].isalnum():
                        temp.append(dartResult[i+3])                
                except : pass
            
            else:
                temp = [int(c) , dartResult[i+1] ]
                try : 
                    if not dartResult[i + 2].isalnum():
                        temp.append(dartResult[i+2])                
                except : pass
            lst.append(temp)
    
    for i,option in enumerate(lst):
        if lst[i][1] == "D": lst[i][0] **= 2
        if lst[i][1] == "T": lst[i][0] **= 3
            
        if len(lst[i]) == 3:
            if lst[i][2] == "*":
                if i == 0: lst[i][0] *= 2
                else:
                    lst[i][0] *= 2
                    lst[i-1][0] *= 2
            
            if lst[i][2] == "#":
                lst[i][0] *= -1
   
    for val in lst:
        answer += val[0]
        
    return answer
```



```
def solution(dartResult):
    answer = 0
    lst = []
    
        
    p = re.compile('(\d+)([SDT])([*#]?)')
    dart = p.findall(dartResult)     
        
    return answer
```



```python
import re

def solution(dartResult):
    answer = 0
    score = []
    
    bonus = {"S" : 1 , "D" : 2 , "T" : 3}
    option = {"" : 1 , "*" : 2 , "#" : -1}
        
    p = re.compile('(\d+)([SDT])([*#]?)')
    darts = p.findall(dartResult)     
    
    for i,dart in enumerate(darts):

        score.append(int(dart[0])**bonus[dart[1]]*option[dart[2]])

        if dart[2] == "*" and i != 0: 
            score[i-1] *= option[dart[2]]
            
    return sum(score)
```







##  방법론



> 문제를 풀어가는 프로세스

```


1. 문제를 읽음	-	뭘 구하는지 , 고려요소? , 문제가 복잡하면 깊게 생각해봄

---

2. 문제를 생각해봄	- 쉬워서 딱 읽었을때 할 수 있을거같은건 하면 됨 

	- 1). 문제를 제대로 이해?
		보통 어려운 문제는 한번 읽어서 이해가 안됨 , 예제 참고하면서 최대한 이해해볼것
	- 2). 문제 접근 방향
		접근 방향이 어려우면 보통 코드를 짜보면서 접근 방향을 수정하면서 하게 됨

3. 코드를 짬
	- 코드를 짜다 잘 안되거나 예상치 못하면 2로 돌아감
---


```



> 문제를 풀어가는데 핋요한 개념

```

문제에 접근하는 과정 과 문제를 풀고나서 풀이에 필요한 개념은 당연히 큰 차이가 있다.
둘다 중요함
접

- 문제에 접근하는데 생각한 개념
- 문제를 푸는데 필요한 개념
```

